from typing import Any, Dict, List, Optional
from .models import Table, DataType
from .storage import StorageEngine

class ExecutionEngine:
    """
    The heart of the database. Executes the plans generated by the parser against the storage engine.
    """
    def __init__(self, storage: StorageEngine):
        """
        Initialize the execution engine.
        
        Args:
            storage: The storage engine instance to use for data access.
        """
        self.storage = storage

    def execute(self, plan: Dict[str, Any]):
        """
        Routes the execution plan to the appropriate handler based on the command type.
        
        Args:
            plan: The execution plan dictionary (AST).
            
        Returns:
            The result of the operation (string message or list of rows).
            
        Raises:
            ValueError: If the command type is unknown.
        """
        cmd_type = plan["type"]
        if cmd_type == "create_table":
            return self._execute_create(plan)
        elif cmd_type == "insert":
            return self._execute_insert(plan)
        elif cmd_type == "select":
            return self._execute_select(plan)
        elif cmd_type == "create_index":
            return self._execute_create_index(plan)
        elif cmd_type == "update":
            return self._execute_update(plan)
        elif cmd_type == "delete":
            return self._execute_delete(plan)
        else:
            raise ValueError(f"Unknown command type: {cmd_type}")

    def _execute_create_index(self, plan: Dict[str, Any]):
        """Executes CREATE INDEX."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")
        
        col_name = plan["column_name"]
        table.create_index(col_name)
        self.storage.save_table(table_name)
        return f"Index '{plan['index_name']}' created on {table_name}({col_name})."

    def _execute_create(self, plan: Dict[str, Any]):
        """Executes CREATE TABLE."""
        table_name = plan["table_name"]
        columns = {col.name: col for col in plan["columns"]}
        table = Table(name=table_name, columns=columns)
        self.storage.create_table(table)
        return f"Table '{table_name}' created."

    def _execute_insert(self, plan: Dict[str, Any]):
        """Executes INSERT INTO."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")

        columns = plan["columns"]
        values = plan["values"]

        row_data = {}
        if columns:
            if len(columns) != len(values):
                raise ValueError("Column count doesn't match value count")
            for col, val in zip(columns, values):
                row_data[col] = val
        else:
            if len(values) != len(table.columns):
                raise ValueError("Value count doesn't match table column count")
            for col_name, val in zip(table.columns.keys(), values):
                row_data[col_name] = val

        table.add_row(row_data)
        self.storage.save_table(table_name)
        return "1 row inserted."

    def _execute_select(self, plan: Dict[str, Any]):
        """
        Executes SELECT queries, including filtering, joining, and projection.
        Optimized to use Hash Index for equality lookups where possible.
        """
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")

        results = table.rows
        join = plan.get("join")

        # Filter optimization using index
        where = plan["where"]
        index_used = False
        if where and not join: # Only optimize simple selects for now
            col = where["column"]
            op = where["operator"]
            val_obj = where["value"]
            
            # We only optimize equality for our simple hash index
            if op == "=" and col in table.indices and not (isinstance(val_obj, dict) and val_obj.get("type") == "column"):
                row_indices = table.indices[col].get(val_obj, [])
                results = [table.rows[i] for i in row_indices]
                index_used = True
        
        # Join Execution (Nested Loop Join)
        if join:
            join_table_name = join["join_table"]
            join_table = self.storage.get_table(join_table_name)
            if not join_table:
                raise ValueError(f"Join table '{join_table_name}' not found")
            
            condition = join["condition"]
            joined_results = []
            for left_row in results:
                for right_row in join_table.rows:
                    if self._evaluate_join_condition(left_row, right_row, condition):
                        # Merge rows, handling potential column name overlaps
                        merged = {**left_row, **right_row}
                        joined_results.append(merged)
            results = joined_results

        # Filter (if index wasn't used, or if there are other conditions)
        # Note: If index was used, we technically don't need to re-check the index condition,
        # but for simplicity/safety against hash collisions (not an issue here but good practice), we re-check.
        if where:
            results = [row for row in results if self._evaluate_where(row, where)]

        # Projection (Selecting specific columns)
        selected_cols = plan["columns"]
        if selected_cols != "*":
            results = [
                {col: row.get(col) for col in selected_cols}
                for row in results
            ]

        # Apply LIMIT
        limit = plan.get("limit")
        if limit is not None:
            results = results[:limit]

        return results

    def _execute_update(self, plan: Dict[str, Any]):
        """Executes UPDATE queries."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")
        
        assignments = plan["assignments"]
        where = plan["where"]
        
        count = 0
        for row in table.rows:
            if not where or self._evaluate_where(row, where):
                for col, val in assignments.items():
                    if col not in table.columns:
                        raise ValueError(f"Column '{col}' not found")
                    if not table.columns[col].validate(val):
                        raise ValueError(f"Invalid value for column '{col}': {val}")
                    row[col] = val
                count += 1
        
        if count > 0:
            # Rebuild all indices for this table because values changed
            for col_name in table.indices:
                table.create_index(col_name)
            self.storage.save_table(table_name)
            
        return f"{count} row(s) updated."

    def _execute_delete(self, plan: Dict[str, Any]):
        """Executes DELETE queries."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")
        
        where = plan["where"]
        
        initial_count = len(table.rows)
        table.rows = [row for row in table.rows if not (not where or self._evaluate_where(row, where))]
        final_count = len(table.rows)
        count = initial_count - final_count
        
        if count > 0:
            # Rebuild indices
            for col_name in table.indices:
                table.create_index(col_name)
            self.storage.save_table(table_name)
            
        return f"{count} row(s) deleted."

    def _evaluate_join_condition(self, left_row: Dict[str, Any], right_row: Dict[str, Any], condition: Dict[str, Any]):
        """Evaluates a JOIN ON condition."""
        col = condition["column"]
        op = condition["operator"]
        val_obj = condition["value"]
        
        left_val = left_row.get(col)
        
        if isinstance(val_obj, dict) and val_obj.get("type") == "column":
            right_val = right_row.get(val_obj["name"])
        else:
            right_val = val_obj

        return self._compare(left_val, op, right_val)

    def _evaluate_where(self, row: Dict[str, Any], where: Dict[str, Any]):
        """Evaluates a WHERE clause against a single row."""
        col = where["column"]
        op = where["operator"]
        val_obj = where["value"]
        row_val = row.get(col)

        if isinstance(val_obj, dict) and val_obj.get("type") == "column":
            # This would be for something like WHERE col1 = col2
            target_val = row.get(val_obj["name"])
        else:
            target_val = val_obj

        return self._compare(row_val, op, target_val)

    def _compare(self, left, op, right):
        """Helper to compare two values with an operator."""
        if op == "=": return left == right
        if op == ">": return left > right
        if op == "<": return left < right
        if op == ">=": return left >= right
        if op == "<=": return left <= right
        if op == "!=": return left != right
        return False