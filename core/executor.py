from typing import Any, Dict, List, Optional
from .models import Table, DataType
from .storage import StorageEngine


class ExecutionEngine:
    """
    The heart of the database. Executes the plans generated by the parser against the storage engine.
    """

    def __init__(self, storage: StorageEngine):
        self.storage = storage

    def execute(self, plan: Dict[str, Any], params: List[Any] = None):
        """
        Routes the execution plan to the appropriate handler based on the command type.
        Supports parameterized queries for security.
        """
        self.current_params = params or []
        self.param_index = 0

        cmd_type = plan["type"]
        if cmd_type == "create_table":
            return self._execute_create(plan)
        elif cmd_type == "insert":
            return self._execute_insert(plan)
        elif cmd_type == "select":
            return self._execute_select(plan)
        elif cmd_type == "create_index":
            return self._execute_create_index(plan)
        elif cmd_type == "update":
            return self._execute_update(plan)
        elif cmd_type == "delete":
            return self._execute_delete(plan)
        else:
            raise ValueError(f"Unknown command type: {cmd_type}")

    def _resolve_value(self, val_obj):
        """Resolves a value, handling placeholders."""
        if isinstance(val_obj, dict) and val_obj.get("type") == "placeholder":
            if self.param_index >= len(self.current_params):
                raise ValueError(
                    "Not enough parameters provided for query placeholders."
                )
            val = self.current_params[self.param_index]
            self.param_index += 1
            return val
        return val_obj

    def _execute_create_index(self, plan: Dict[str, Any]):
        """Executes CREATE INDEX."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")

        col_name = plan["column_name"]
        table.create_index(col_name)
        self.storage.save_table(table_name)
        return f"Index '{plan['index_name']}' created on {table_name}({col_name})."

    def _execute_create(self, plan: Dict[str, Any]):
        """Executes CREATE TABLE."""
        table_name = plan["table_name"]
        columns = {col.name: col for col in plan["columns"]}
        table = Table(name=table_name, columns=columns)
        self.storage.create_table(table)
        return f"Table '{table_name}' created."

    def _execute_insert(self, plan: Dict[str, Any]):
        """Executes INSERT INTO."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")

        columns = plan["columns"]
        # Resolve all values in the list
        values = [self._resolve_value(v) for v in plan["values"]]

        row_data = {}
        if columns:
            if len(columns) != len(values):
                raise ValueError("Column count doesn't match value count")
            for col, val in zip(columns, values):
                row_data[col] = val
        else:
            if len(values) != len(table.columns):
                raise ValueError("Value count doesn't match table column count")
            for col_name, val in zip(table.columns.keys(), values):
                row_data[col_name] = val

        table.add_row(row_data)
        self.storage.save_table(table_name)
        return "1 row inserted."

    def _execute_select(self, plan: Dict[str, Any]):
        """Executes SELECT queries."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")

        results = table.rows
        join = plan.get("join")
        where = plan["where"]

        # Resolve WHERE clause once
        resolved_where = None
        if where:
            resolved_where = where.copy()
            resolved_where["value"] = self._resolve_value(where["value"])

        # Filter optimization using index
        index_used = False
        if resolved_where and not join:
            col = resolved_where["column"]
            op = resolved_where["operator"]
            val_obj = resolved_where["value"]

            if (
                op == "="
                and col in table.indices
                and not (isinstance(val_obj, dict) and val_obj.get("type") == "column")
            ):
                row_indices = table.indices[col].get(val_obj, [])
                results = [table.rows[i] for i in row_indices]
                index_used = True

        # Join Execution
        if join:
            # ... (join logic remains same)
            join_table_name = join["join_table"]
            join_table = self.storage.get_table(join_table_name)
            if not join_table:
                raise ValueError(f"Join table '{join_table_name}' not found")

            condition = join["condition"]
            joined_results = []
            for left_row in results:
                for right_row in join_table.rows:
                    if self._evaluate_join_condition(left_row, right_row, condition):
                        merged = {**left_row, **right_row}
                        joined_results.append(merged)
            results = joined_results

        # Filter
        if resolved_where:
            results = [
                row for row in results if self._evaluate_where(row, resolved_where)
            ]

        # Projection
        selected_cols = plan["columns"]
        if selected_cols != "*":
            results = [{col: row.get(col) for col in selected_cols} for row in results]

        # Limit
        limit = plan.get("limit")
        if limit is not None:
            results = results[:limit]

        return results

    def _execute_update(self, plan: Dict[str, Any]):
        """Executes UPDATE queries."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")

        assignments = plan["assignments"]
        where = plan["where"]

        # Resolve values
        resolved_assignments = {
            k: self._resolve_value(v) for k, v in assignments.items()
        }
        resolved_where = None
        if where:
            resolved_where = where.copy()
            resolved_where["value"] = self._resolve_value(where["value"])

        count = 0
        for row in table.rows:
            if not resolved_where or self._evaluate_where(row, resolved_where):
                for col, val in resolved_assignments.items():
                    if col not in table.columns:
                        raise ValueError(f"Column '{col}' not found")
                    if not table.columns[col].validate(val):
                        raise ValueError(f"Invalid value for column '{col}': {val}")
                    row[col] = val
                count += 1

        if count > 0:
            for col_name in table.indices:
                table.create_index(col_name)
            self.storage.save_table(table_name)

        return f"{count} row(s) updated."

    def _execute_delete(self, plan: Dict[str, Any]):
        """Executes DELETE queries."""
        table_name = plan["table_name"]
        table = self.storage.get_table(table_name)
        if not table:
            raise ValueError(f"Table '{table_name}' not found")

        where = plan["where"]
        resolved_where = None
        if where:
            resolved_where = where.copy()
            resolved_where["value"] = self._resolve_value(where["value"])

        initial_count = len(table.rows)
        table.rows = [
            row
            for row in table.rows
            if not (not resolved_where or self._evaluate_where(row, resolved_where))
        ]
        final_count = len(table.rows)
        count = initial_count - final_count

        if count > 0:
            for col_name in table.indices:
                table.create_index(col_name)
            self.storage.save_table(table_name)

        return f"{count} row(s) deleted."

    def _evaluate_join_condition(
        self,
        left_row: Dict[str, Any],
        right_row: Dict[str, Any],
        condition: Dict[str, Any],
    ):
        """Evaluates a JOIN ON condition."""
        col = condition["column"]
        op = condition["operator"]
        # Join conditions shouldn't have placeholders typically in this simple grammar
        val_obj = condition["value"]

        left_val = left_row.get(col)

        if isinstance(val_obj, dict) and val_obj.get("type") == "column":
            right_val = right_row.get(val_obj["name"])
        else:
            right_val = val_obj

        return self._compare(left_val, op, right_val)

    def _evaluate_where(self, row: Dict[str, Any], where: Dict[str, Any]):
        """Evaluates a WHERE clause against a single row."""
        col = where["column"]
        op = where["operator"]
        val_obj = where["value"]  # Already resolved
        row_val = row.get(col)

        if isinstance(val_obj, dict) and val_obj.get("type") == "column":
            target_val = row.get(val_obj["name"])
        else:
            target_val = val_obj

        return self._compare(row_val, op, target_val)

    def _compare(self, left, op, right):
        if op == "=":
            return left == right
        if op == ">":
            return left > right
        if op == "<":
            return left < right
        if op == ">=":
            return left >= right
        if op == "<=":
            return left <= right
        if op == "!=":
            return left != right
        return False
