from lark import Lark, Transformer, v_args
from .models import DataType, Column

# The SQL Grammar defined using Lark's EBNF-like syntax.
# It defines rules for creating tables, indices, and performing CRUD operations.
sql_grammar = r"""
    ?start: statement

    ?statement: create_table_stmt
             | insert_stmt
             | select_stmt
             | create_index_stmt
             | update_stmt
             | delete_stmt

    # --- DDL: Data Definition Language ---
    create_table_stmt: "CREATE" "TABLE" CNAME "(" col_def ("," col_def)* ")"
    create_index_stmt: "CREATE" "INDEX" CNAME "ON" CNAME "(" CNAME ")"
    
    col_def: CNAME type [constraint*]
    type: "INTEGER" -> type_int
        | "TEXT"    -> type_text
        | "BOOLEAN" -> type_bool
        | "FLOAT"   -> type_float
    
    constraint: "PRIMARY" "KEY" -> pk
              | "UNIQUE"      -> unique
              | "NOT" "NULL"  -> not_null

    # --- DML: Data Manipulation Language ---
    insert_stmt: "INSERT" "INTO" CNAME [column_list] "VALUES" "(" value_list ")"
    value_list: value ("," value)*

    update_stmt: "UPDATE" CNAME "SET" assignment ("," assignment)* [where_clause]
    assignment: CNAME "=" value
    
    delete_stmt: "DELETE" "FROM" CNAME [where_clause]
    
    # --- DQL: Data Query Language ---
    select_stmt: "SELECT" (ASTERISK | column_list) "FROM" CNAME [join_clause] [where_clause] [limit_clause]
    limit_clause: "LIMIT" INT
    join_clause: [join_type] "JOIN" CNAME "ON" condition
    join_type: "LEFT" -> left_join
             | "INNER" -> inner_join
    column_list: "(" CNAME ("," CNAME)* ")" -> col_list_paren
               | CNAME ("," CNAME)*        -> col_list_plain
    ASTERISK: "*"

    # --- Common Clauses ---
    where_clause: "WHERE" condition
    condition: CNAME OPERATOR cond_value
    ?cond_value: value
               | CNAME -> col_ref
    OPERATOR: "=" | ">" | "<" | ">=" | "<=" | "!="

    # --- Values and Types ---
    ?value: SIGNED_INT      -> int
          | SIGNED_FLOAT    -> float
          | STRING          -> string
          | "TRUE"          -> true
          | "FALSE"         -> false
          | "NULL"          -> null
          | "?"             -> placeholder

    STRING: "'" /[^']*/ "'"
    SIGNED_FLOAT: /[-+]?((\d+\.\d*|\.\d+)([eE][-+]?\d+)?|\d+[eE][-+]?\d+)/
    %import common.CNAME
    %import common.SIGNED_INT
    %import common.INT
    %import common.WS
    %ignore WS
"""


class SQLTransformer(Transformer):
    """
    Transforms the parse tree generated by Lark into a structured dictionary (AST)
    that the ExecutionEngine can understand.
    """

    def create_table_stmt(self, items):
        """Builds plan for CREATE TABLE."""
        table_name = str(items[0])
        columns = items[1:]
        return {"type": "create_table", "table_name": table_name, "columns": columns}

    def create_index_stmt(self, items):
        """Builds plan for CREATE INDEX."""
        return {
            "type": "create_index",
            "index_name": str(items[0]),
            "table_name": str(items[1]),
            "column_name": str(items[2]),
        }

    def col_def(self, items):
        """Parses column definition and constraints."""
        name = str(items[0])
        data_type = items[1]
        constraints = items[2:] if len(items) > 2 else []

        is_pk = "pk" in constraints
        is_unique = "unique" in constraints
        is_nullable = "not_null" not in constraints

        return Column(
            name=name,
            data_type=data_type,
            is_primary_key=is_pk,
            is_unique=is_unique,
            is_nullable=is_nullable,
        )

    # Type mapping methods
    def type_int(self, _):
        return DataType.INTEGER

    def type_text(self, _):
        return DataType.TEXT

    def type_bool(self, _):
        return DataType.BOOLEAN

    def type_float(self, _):
        return DataType.FLOAT

    # Constraint mapping methods
    def pk(self, _):
        return "pk"

    def unique(self, _):
        return "unique"

    def not_null(self, _):
        return "not_null"

    def insert_stmt(self, items):
        """Builds plan for INSERT INTO."""
        table_name = str(items[0])
        if len(items) == 3:
            columns = items[1]
            values = items[2]
        else:
            columns = None
            values = items[1]

        return {
            "type": "insert",
            "table_name": table_name,
            "columns": columns,
            "values": values,
        }

    def update_stmt(self, items):
        """Builds plan for UPDATE."""
        table_name = str(items[0])
        assignments = {}
        where = None
        for item in items[1:]:
            if isinstance(item, tuple):
                assignments[item[0]] = item[1]
            else:
                where = item
        return {
            "type": "update",
            "table_name": table_name,
            "assignments": assignments,
            "where": where,
        }

    def assignment(self, items):
        return (str(items[0]), items[1])

    def delete_stmt(self, items):
        """Builds plan for DELETE."""
        table_name = str(items[0])
        where = items[1] if len(items) > 1 else None
        return {"type": "delete", "table_name": table_name, "where": where}

    def value_list(self, items):
        return items

    def col_list_paren(self, items):
        return [str(i) for i in items]

    def col_list_plain(self, items):
        return [str(i) for i in items]

    def select_stmt(self, items):
        """Builds plan for SELECT."""
        columns = items[0]
        table_name = str(items[1])
        join = None
        where = None
        limit = None

        remaining = items[2:]
        for item in remaining:
            if item is None:
                continue
            if isinstance(item, dict) and "join_table" in item:
                join = item
            elif isinstance(item, dict) and "limit" in item:
                limit = item["limit"]
            else:
                where = item

        return {
            "type": "select",
            "table_name": table_name,
            "columns": columns,
            "join": join,
            "where": where,
            "limit": limit,
        }

    def limit_clause(self, items):
        return {"limit": int(items[0])}

    def join_clause(self, items):
        if len(items) == 3:
            return {"type": items[0], "join_table": str(items[1]), "condition": items[2]}
        return {"type": "inner", "join_table": str(items[0]), "condition": items[1]}

    def left_join(self, _):
        return "left"

    def inner_join(self, _):
        return "inner"

    def ASTERISK(self, _):
        return "*"

    def where_clause(self, items):
        return items[0]

    def col_ref(self, items):
        return {"type": "column", "name": str(items[0])}

    def condition(self, items):
        val = items[2]
        return {"column": str(items[0]), "operator": str(items[1]), "value": val}

    # Value parsing methods
    def int(self, items):
        return int(items[0])

    def string(self, items):
        return str(items[0][1:-1])

    def float(self, items):
        return float(items[0])

    def true(self, _):
        return True

    def false(self, _):
        return False

    def null(self, _):
        return None

    def placeholder(self, _):
        return {"type": "placeholder"}


class SQLParser:
    """
    Facade for the Lark parser. Converts SQL strings into execution plans.
    """

    def __init__(self):
        self.parser = Lark(sql_grammar, parser="lalr", transformer=SQLTransformer())

    def parse(self, sql: str):
        """Parses a SQL string and returns a dictionary representing the operation."""
        return self.parser.parse(sql)
